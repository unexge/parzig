const std = @import("std");
const parzig = @import("parzig");

pub fn main() !void {
    var gpa: std.heap.DebugAllocator(.{}) = .init;
    defer {
        std.debug.assert(gpa.deinit() == .ok);
    }
    const allocator = gpa.allocator();

    const input = "./parquet.thrift";
    const output = "./src/generated/parquet.zig";
    std.debug.print("Generating {s} from {s}\n", .{ output, input });

    var input_file = try std.fs.cwd().openFile(input, .{});
    defer input_file.close();

    var reader_buf: [1024]u8 = undefined;
    var reader = input_file.reader(&reader_buf);
    const size = try reader.getSize();

    const source = try reader.interface.readAlloc(allocator, size);
    defer allocator.free(source);

    var document = try parzig.thrift.Document.init(allocator, source);
    defer document.deinit();

    var root = try parzig.thrift.translate(allocator, &document);
    defer root.deinit(allocator);
    defer allocator.free(root.source);

    var output_file = try std.fs.cwd().createFile(output, .{});
    defer output_file.close();

    var write_buf: [1024]u8 = undefined;
    var writer = output_file.writer(&write_buf);

    try writer.interface.writeAll(
        \\// Generated by `zig build generate`.
        \\// DO NOT EDIT.
        \\
        \\
    );
    try root.render(allocator, &writer.interface, .{});
    try writer.interface.flush();

    std.debug.print("Done\n", .{});

    return std.process.cleanExit();
}
