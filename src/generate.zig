const std = @import("std");
const parzig = @import("parzig");

const Io = std.Io;

pub fn main(init: std.process.Init.Minimal) !void {
    var gpa: std.heap.DebugAllocator(.{}) = .init;
    defer {
        std.debug.assert(gpa.deinit() == .ok);
    }
    const allocator = gpa.allocator();

    var threaded: Io.Threaded = .init(allocator, .{ .environ = init.environ });
    defer threaded.deinit();
    const io = threaded.io();

    const input = "./parquet.thrift";
    const output = "./src/generated/parquet.zig";
    std.debug.print("Generating {s} from {s}\n", .{ output, input });

    var input_file = try Io.Dir.cwd().openFile(io, input, .{ .mode = .read_only });
    defer input_file.close(io);

    var reader_buf: [1024]u8 = undefined;
    var reader = input_file.reader(io, &reader_buf);
    const size = try reader.getSize();

    const source = try reader.interface.readAlloc(allocator, size);
    defer allocator.free(source);

    var document = try parzig.thrift.Document.init(allocator, source);
    defer document.deinit();

    var root = try parzig.thrift.translate(allocator, &document);
    defer root.deinit(allocator);
    defer allocator.free(root.source);

    var output_file = try Io.Dir.cwd().createFile(io, output, .{});
    defer output_file.close(io);

    var write_buf: [1024]u8 = undefined;
    var writer = output_file.writer(io, &write_buf);

    try writer.interface.writeAll(
        \\// Generated by `zig build generate`.
        \\// DO NOT EDIT.
        \\
        \\
    );
    try root.render(allocator, &writer.interface, .{});
    try writer.interface.flush();

    std.debug.print("Done\n", .{});

    return std.process.cleanExit(io);
}
