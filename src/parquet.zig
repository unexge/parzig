// Generated by `zig build generate`.
// DO NOT EDIT.
//
const std = @import("std");
const List = std.ArrayList;
const Type = enum(u8) {
    BOOLEAN = 0,
    INT32 = 1,
    INT64 = 2,
    INT96 = 3,
    FLOAT = 4,
    DOUBLE = 5,
    BYTE_ARRAY = 6,
    FIXED_LEN_BYTE_ARRAY = 7,
};
const ConvertedType = enum(u8) {
    UTF8 = 0,
    MAP = 1,
    MAP_KEY_VALUE = 2,
    LIST = 3,
    ENUM = 4,
    DECIMAL = 5,
    DATE = 6,
    TIME_MILLIS = 7,
    TIME_MICROS = 8,
    TIMESTAMP_MILLIS = 9,
    TIMESTAMP_MICROS = 10,
    UINT_8 = 11,
    UINT_16 = 12,
    UINT_32 = 13,
    UINT_64 = 14,
    INT_8 = 15,
    INT_16 = 16,
    INT_32 = 17,
    INT_64 = 18,
    JSON = 19,
    BSON = 20,
    INTERVAL = 21,
};
const FieldRepetitionType = enum(u8) {
    REQUIRED = 0,
    OPTIONAL = 1,
    REPEATED = 2,
};
const SizeStatistics = struct {
    unencoded_byte_array_data_bytes: i64,
    repetition_level_histogram: List(i64),
    definition_level_histogram: List(i64),
};
const Statistics = struct {
    max: []u8,
    min: []u8,
    null_count: i64,
    distinct_count: i64,
    max_value: []u8,
    min_value: []u8,
    is_max_value_exact: bool,
    is_min_value_exact: bool,
};
const StringType = struct {};
const UUIDType = struct {};
const MapType = struct {};
const ListType = struct {};
const EnumType = struct {};
const DateType = struct {};
const Float16Type = struct {};
const NullType = struct {};
const DecimalType = struct {
    scale: i32,
    precision: i32,
};
const MilliSeconds = struct {};
const MicroSeconds = struct {};
const NanoSeconds = struct {};
const TimeUnit = union {
    MILLIS: MilliSeconds,
    MICROS: MicroSeconds,
    NANOS: NanoSeconds,
};
const TimestampType = struct {
    isAdjustedToUTC: bool,
    unit: TimeUnit,
};
const TimeType = struct {
    isAdjustedToUTC: bool,
    unit: TimeUnit,
};
const IntType = struct {
    bitWidth: i8,
    isSigned: bool,
};
const JsonType = struct {};
const BsonType = struct {};
const LogicalType = union {
    STRING: StringType,
    MAP: MapType,
    LIST: ListType,
    ENUM: EnumType,
    DECIMAL: DecimalType,
    DATE: DateType,
    TIME: TimeType,
    TIMESTAMP: TimestampType,
    INTEGER: IntType,
    UNKNOWN: NullType,
    JSON: JsonType,
    BSON: BsonType,
    UUID: UUIDType,
    FLOAT16: Float16Type,
};
const SchemaElement = struct {
    type: Type,
    type_length: i32,
    repetition_type: FieldRepetitionType,
    name: []u8,
    num_children: i32,
    converted_type: ConvertedType,
    scale: i32,
    precision: i32,
    field_id: i32,
    logicalType: LogicalType,
};
const Encoding = enum(u8) {
    PLAIN = 0,
    PLAIN_DICTIONARY = 2,
    RLE = 3,
    BIT_PACKED = 4,
    DELTA_BINARY_PACKED = 5,
    DELTA_LENGTH_BYTE_ARRAY = 6,
    DELTA_BYTE_ARRAY = 7,
    RLE_DICTIONARY = 8,
    BYTE_STREAM_SPLIT = 9,
};
const CompressionCodec = enum(u8) {
    UNCOMPRESSED = 0,
    SNAPPY = 1,
    GZIP = 2,
    LZO = 3,
    BROTLI = 4,
    LZ4 = 5,
    ZSTD = 6,
    LZ4_RAW = 7,
};
const PageType = enum(u8) {
    DATA_PAGE = 0,
    INDEX_PAGE = 1,
    DICTIONARY_PAGE = 2,
    DATA_PAGE_V2 = 3,
};
const BoundaryOrder = enum(u8) {
    UNORDERED = 0,
    ASCENDING = 1,
    DESCENDING = 2,
};
const DataPageHeader = struct {
    num_values: i32,
    encoding: Encoding,
    definition_level_encoding: Encoding,
    repetition_level_encoding: Encoding,
    statistics: Statistics,
};
const IndexPageHeader = struct {};
const DictionaryPageHeader = struct {
    num_values: i32,
    encoding: Encoding,
    is_sorted: bool,
};
const DataPageHeaderV2 = struct {
    num_values: i32,
    num_nulls: i32,
    num_rows: i32,
    encoding: Encoding,
    definition_levels_byte_length: i32,
    repetition_levels_byte_length: i32,
    is_compressed: bool,
    statistics: Statistics,
};
const SplitBlockAlgorithm = struct {};
const BloomFilterAlgorithm = union {
    BLOCK: SplitBlockAlgorithm,
};
const XxHash = struct {};
const BloomFilterHash = union {
    XXHASH: XxHash,
};
const Uncompressed = struct {};
const BloomFilterCompression = union {
    UNCOMPRESSED: Uncompressed,
};
const BloomFilterHeader = struct {
    numBytes: i32,
    algorithm: BloomFilterAlgorithm,
    hash: BloomFilterHash,
    compression: BloomFilterCompression,
};
const PageHeader = struct {
    type: PageType,
    uncompressed_page_size: i32,
    compressed_page_size: i32,
    crc: i32,
    data_page_header: DataPageHeader,
    index_page_header: IndexPageHeader,
    dictionary_page_header: DictionaryPageHeader,
    data_page_header_v2: DataPageHeaderV2,
};
const KeyValue = struct {
    key: []u8,
    value: []u8,
};
const SortingColumn = struct {
    column_idx: i32,
    descending: bool,
    nulls_first: bool,
};
const PageEncodingStats = struct {
    page_type: PageType,
    encoding: Encoding,
    count: i32,
};
const ColumnMetaData = struct {
    type: Type,
    encodings: List(Encoding),
    path_in_schema: List([]u8),
    codec: CompressionCodec,
    num_values: i64,
    total_uncompressed_size: i64,
    total_compressed_size: i64,
    key_value_metadata: List(KeyValue),
    data_page_offset: i64,
    index_page_offset: i64,
    dictionary_page_offset: i64,
    statistics: Statistics,
    encoding_stats: List(PageEncodingStats),
    bloom_filter_offset: i64,
    bloom_filter_length: i32,
    size_statistics: SizeStatistics,
};
const EncryptionWithFooterKey = struct {};
const EncryptionWithColumnKey = struct {
    path_in_schema: List([]u8),
    key_metadata: []u8,
};
const ColumnCryptoMetaData = union {
    ENCRYPTION_WITH_FOOTER_KEY: EncryptionWithFooterKey,
    ENCRYPTION_WITH_COLUMN_KEY: EncryptionWithColumnKey,
};
const ColumnChunk = struct {
    file_path: []u8,
    file_offset: i64,
    meta_data: ColumnMetaData,
    offset_index_offset: i64,
    offset_index_length: i32,
    column_index_offset: i64,
    column_index_length: i32,
    crypto_metadata: ColumnCryptoMetaData,
    encrypted_column_metadata: []u8,
};
const RowGroup = struct {
    columns: List(ColumnChunk),
    total_byte_size: i64,
    num_rows: i64,
    sorting_columns: List(SortingColumn),
    file_offset: i64,
    total_compressed_size: i64,
    ordinal: i16,
};
const TypeDefinedOrder = struct {};
const ColumnOrder = union {
    TYPE_ORDER: TypeDefinedOrder,
};
const PageLocation = struct {
    offset: i64,
    compressed_page_size: i32,
    first_row_index: i64,
};
const OffsetIndex = struct {
    page_locations: List(PageLocation),
    unencoded_byte_array_data_bytes: List(i64),
};
const ColumnIndex = struct {
    null_pages: List(bool),
    min_values: List([]u8),
    max_values: List([]u8),
    boundary_order: BoundaryOrder,
    null_counts: List(i64),
    repetition_level_histograms: List(i64),
    definition_level_histograms: List(i64),
};
const AesGcmV1 = struct {
    aad_prefix: []u8,
    aad_file_unique: []u8,
    supply_aad_prefix: bool,
};
const AesGcmCtrV1 = struct {
    aad_prefix: []u8,
    aad_file_unique: []u8,
    supply_aad_prefix: bool,
};
const EncryptionAlgorithm = union {
    AES_GCM_V1: AesGcmV1,
    AES_GCM_CTR_V1: AesGcmCtrV1,
};
const FileMetaData = struct {
    version: i32,
    schema: List(SchemaElement),
    num_rows: i64,
    row_groups: List(RowGroup),
    key_value_metadata: List(KeyValue),
    created_by: []u8,
    column_orders: List(ColumnOrder),
    encryption_algorithm: EncryptionAlgorithm,
    footer_signing_key_metadata: []u8,
};
const FileCryptoMetaData = struct {
    encryption_algorithm: EncryptionAlgorithm,
    key_metadata: []u8,
};
